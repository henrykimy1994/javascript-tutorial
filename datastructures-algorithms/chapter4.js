// When facing several possible ways to of implementing the same ADT, consider the efficiency of each concrete implementation
// An analysis of the involved algorithms
// What data structures should you pick? 
// What algorithm should you pick? 
// Objectively analyzing their performance
{
    // Performance - measuring the efficiency of a given algorithm
    // time / RAM
    // Often, faster-performing algorithms require larger amounts of memory, vice versa

    // The space complexity of algorithms is fairly stable
    // Grows in direct proportion to the number of input elements
    // Time complexity results in many variations
    // Providing a solid basis for choosing which data structure to use and which algorithms to implement

    // Time complexity - how long the algorithm takes to perform its function in relation to the size of tis input data
}
 {
    // Complexity 

    // n - the input parameter
    // analysis of algorithm - time complexity as a function of that input
    // algorithm's performance may be directly linked to the data itself - in order sequence vs. disordered or random sequence
    // worst / average / upper bound
 }
 {
    // Notations for Complexity

    // Asymptotic notations
    
    // big O notation - stands for order(Ordnung)
    // groups functions according to how they behave for growing values of their n parameter
    // n - could be the number of values to sort, the size of a set to be searched, or how many keys are added to a tree(case-by-case)
    // describing a function in terms of its big O behavior implies an upper bound on how the function grows
    // behavior of a function f(n) = O(g(n)) - means that when n grows, both functions grow in the same proportion
    
 }